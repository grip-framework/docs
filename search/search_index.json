{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Prelude","text":"<p>Grip is a lightweight microframework for building RESTful web applications in the Crystal programming language. Designed for modularity, simplicity, and high performance, Grip leverages Crystal\u2019s capabilities to create scalable APIs. It provides extensible middleware, a flexible router, and exceptional throughput, achieving up to 1,663,946 requests/second for plain text responses.</p>"},{"location":"#framework-features","title":"Framework Features","text":"<ul> <li> <p>Microframework Design: Grip focuses on simplicity for building RESTful APIs, enabling rapid development while supporting complex applications through modular extensions.</p> </li> <li> <p>Middleware (\"Pipes\"): Integrated middleware, implemented as <code>HTTP::Handler</code> classes, processes and modifies request/response contexts (e.g., adding headers, authentication) before forwarding to endpoints.</p> </li> <li> <p>Router: Inspired by the Phoenix framework, Grip\u2019s router offers expressive routing with macros like <code>get</code>, <code>scope</code>, <code>pipe_through</code>, and <code>forward</code> for defining endpoints and pipelines.</p> </li> <li> <p>Extensibility: Developers can create custom middleware, controllers, and error handlers to tailor functionality to specific needs.</p> </li> <li> <p>High Performance: Optimized for speed, Grip delivers exceptional throughput, making it ideal for high-performance API development.</p> </li> </ul>"},{"location":"#recommended-project-structure","title":"Recommended Project Structure","text":"<p>A typical Grip application follows an organized structure to separate business logic, web interactions, and dependencies. Below is the recommended structure for a project named <code>Echo</code>:</p> <pre><code>Echo/                       # Project root directory\n\u251c\u2500\u2500 lib/                    # External dependencies installed via shards.yml (e.g., Grip framework)\n\u251c\u2500\u2500 src/                    # Application source code\n\u2502   \u251c\u2500\u2500 application.cr      # Main entry file defining the Application class and routes\n\u2502   \u251c\u2500\u2500 echo/               # Business logic layer (e.g., database models, services)\n\u2502   \u2502   \u2514\u2500\u2500 ...             # Additional files for models, repositories, or domain logic\n\u2502   \u251c\u2500\u2500 echo_web/           # Web layer for HTTP request/response handling\n\u2502   \u2502   \u251c\u2500\u2500 controllers/    # Controllers for processing HTTP requests\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...         # Controller files (e.g., DemoController)\n\u2502   \u2502   \u251c\u2500\u2500 views/          # Templates for rendering responses (e.g., JSON, HTML)\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...         # View files\n\u251c\u2500\u2500 shards.yml              # Dependency configuration file\n</code></pre>"},{"location":"#structure-details","title":"Structure Details","text":"<ul> <li> <p>lib/: Contains external libraries (e.g., Grip) installed via <code>shards install</code>, managed by Crystal\u2019s dependency manager.</p> </li> <li> <p>src/application.cr: The application entry point, defining the <code>Application</code> class (inheriting from <code>Grip::Application</code>). It configures middleware via a <code>property handlers</code> array and sets up routes using macros like <code>get</code> or <code>forward</code>.</p> </li> <li> <p>src/echo/: Houses business logic, including database models, services, or other domain-specific functionality, ensuring separation from web concerns.</p> </li> <li> <p>src/echo_web/: Manages HTTP interactions, with controllers (e.g., <code>DemoController</code>) handling requests and views defining response formats (e.g., JSON, HTML).</p> </li> <li> <p>shards.yml: Specifies project metadata and dependencies, such as <code>grip: { github: grip-framework/grip }</code>.</p> </li> </ul>"},{"location":"#example-setup","title":"Example Setup","text":"<p>To create a Grip application with the above structure:</p> <ol> <li> <p>Initialize a Crystal project: <code>crystal init app echo &amp;&amp; cd echo</code>.</p> </li> <li> <p>Add Grip to <code>shards.yml</code>:    <code>yaml    dependencies:      grip:        github: grip-framework/grip</code></p> </li> <li> <p>Install dependencies: <code>shards install</code>.</p> </li> <li> <p>Define the application in <code>src/application.cr</code>, configuring handlers and routes (see previous examples for controller and route definitions).</p> </li> <li> <p>Run the server: <code>crystal src/application.cr</code>.</p> </li> </ol> <p>This structure and Grip\u2019s features provide a robust foundation for building scalable, high-performance RESTful applications in Crystal.</p>"},{"location":"advanced_routing/","title":"Advanced routing","text":"<p>The more advanced the route is the more time it takes when executed, since the call to the index function is an indirect call, meaning that the <code>index/1</code> never existed in the <code>Grip::Controllers::HTTP</code> class it needs to be wrapped in a <code>Proc</code> which then needs to be called.</p> <pre><code># AuthorizationHandler adds an Authorization header to incoming HTTP requests.\nclass AuthorizationHandler\n  include HTTP::Handler\n\n  # Adds a Bearer token to the request's Authorization header.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The modified context with the added header.\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context.put_req_header(\"Authorization\", \"Bearer eyMANEmJeFF=\")\n  end\nend\n\n# DemoController handles HTTP requests for specific routes.\nclass DemoController\n  include Grip::Controllers::HTTP\n\n  # Responds to GET requests with a JSON response.\n  # The index method is wrapped in a Proc for routing, as it is indirectly called by Grip.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a JSON response (nil in this case).\n  def index(context : HTTP::Server::Context) : HTTP::Server::Context\n    context.json(nil)\n  end\nend\n\n# Application configures and runs a Grip web application.\nclass Application\n  include Grip::Application\n\n  # List of HTTP handlers for processing incoming requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::Pipeline.new, # Manages the request pipeline.\n    Grip::Handlers::HTTP.new     # Handles core HTTP protocol logic.\n  ] of HTTP::Handler\n\n  # Initializes the application and configures routes.\n  def initialize\n    routes\n  end\n\n  # Defines routing structure and pipelines for the application.\n  def routes\n    # Pipeline for API requests, applying authorization logic.\n    pipeline :api, [\n      AuthorizationHandler.new # Adds Bearer token to requests.\n    ]\n\n    # Pipeline for web requests, enabling response compression.\n    pipeline :web, [\n      HTTP::CompressHandler.new # Compresses HTTP responses.\n    ]\n\n    # Routes under the root path (\"/\").\n    scope \"/\" do\n      pipe_through :web # Applies compression to responses.\n      pipe_through :api # Applies authorization header.\n\n      # Maps GET \"/\" to DemoController#index, wrapped in a Proc for indirect dispatch.\n      get \"/\", DemoController, as: :index\n    end\n\n    # Routes under the \"/api\" namespace.\n    scope \"/api\" do\n      pipe_through :api # Applies authorization header.\n\n      # Routes under the \"/api/v1\" namespace.\n      scope \"/v1\" do\n        # Maps GET \"/api/v1/\" to DemoController#index, wrapped in a Proc for indirect dispatch.\n        get \"/\", DemoController, as: :index\n      end\n    end\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"},{"location":"application/","title":"Application","text":"<p>Application module is a building block which initializes the crucial parts of the web-framework, it contains the main handler stack and the HTTP server.</p> <pre><code># Application is a building class that initializes the core components of the Grip web framework.\n# It manages the main handler stack and the HTTP server.\nclass Application\n  include Grip::Application\n\n  # List of HTTP handlers for processing incoming requests.\n  property handlers : Array(HTTP::Handler) = [] of HTTP::Handler\n\n  # Initializes the application\n  def initialize\n  end\n\n  # Defines the host address of the server.\n  # @return [String] The host address (e.g., \"0.0.0.0\").\n  def host : String\n    \"0.0.0.0\"\n  end\n\n  # Placeholder for custom configuration or logic.\n  # @return [Nil] No return value by default.\n  def custom : Nil\n    nil\n  end\n\n  # Defines the port on which the server listens.\n  # @return [Int32] The port number (e.g., 4004).\n  def port : Int32\n    4004\n  end\n\n  # Determines if the server reuses the port.\n  # @return [Bool] True if port reuse is enabled, false otherwise.\n  def reuse_port : Bool\n    true\n  end\n\n  # Defines the SSL key file location for the application.\n  # @return [String] The path to the SSL key file, if set.\n  def key_file : String\n    ENV[\"KEY\"]? || \"\"\n  end\n\n  # Defines the SSL certificate file location for the application.\n  # @return [String] The path to the SSL certificate file, if set.\n  def cert_file : String\n    ENV[\"CERTIFICATE\"]? || \"\"\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"},{"location":"basic_routing/","title":"Basic routing","text":"<p>Routing is the key feature which distinguishes Grip from other Crystal based web frameworks.</p> <pre><code># DemoController handles HTTP requests for specific routes.\nclass DemoController\n  include Grip::Controllers::HTTP\n\n  # Responds to GET requests with a JSON response.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a JSON response (nil in this case).\n  def get(context : HTTP::Server::Context) : HTTP::Server::Context\n    context.json(nil)\n  end\nend\n\n# Application configures and runs a Grip web application.\nclass Application\n  include Grip::Application\n\n  # List of HTTP handlers for processing incoming requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::HTTP.new # Handles core HTTP protocol logic.\n  ] of HTTP::Handler\n\n  # Initializes the application and configures routes.\n  def initialize\n    routes\n  end\n\n  # Defines routing structure and pipelines for the application.\n  def routes\n    # Maps GET \"/\" to DemoController#get\n    get \"/\", DemoController\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"},{"location":"context/","title":"Context","text":"<p>The <code>Context</code> class in the <code>Grip</code> module provides a set of helper methods to simplify HTTP request and response handling in a Crystal-based HTTP server. These methods enable fluent manipulation of headers, cookies, status codes, and response content, with most returning <code>self</code> for method chaining.</p>"},{"location":"context/#available-methods","title":"Available Methods","text":"<ul> <li><code>exec/0</code></li> <li><code>delete_req_header/1</code></li> <li><code>delete_resp_header/1</code></li> <li><code>get_req_header/1</code></li> <li><code>get_req_header?/1</code></li> <li><code>get_req_cookie/1</code></li> <li><code>get_resp_header/1</code></li> <li><code>halt/0</code></li> <li><code>merge_resp_headers/1</code></li> <li><code>put_req_header/2</code></li> <li><code>put_resp_header/2</code></li> <li><code>put_resp_cookie/2</code></li> <li><code>put_status/1</code></li> <li><code>send_file/1</code></li> <li><code>send_resp/1</code></li> <li><code>json/2</code></li> <li><code>html/2</code></li> <li><code>text/2</code></li> <li><code>binary/2</code></li> <li><code>fetch_json_params/0</code></li> <li><code>fetch_query_params/0</code></li> <li><code>fetch_body_params/0</code></li> <li><code>fetch_file_params/0</code></li> <li><code>fetch_path_params/0</code></li> <li><code>redirect/2</code></li> </ul>"},{"location":"context/#exec","title":"exec","text":"<p>Run a block in the context scope, allowing chained operations.</p> <pre><code>def get(context : Context)\n  context.exec do\n    put_status(201) # Put a response status code.\n    put_resp_header(\"Server\", \"TornadoServer/6.0.4\") # Put a response header.\n    json( # Respond with JSON encoded data.\n      {\n        \"id\" =&gt; 1\n      }\n    )\n  end\nend\n</code></pre>"},{"location":"context/#delete_req_header","title":"delete_req_header","text":"<p>Deletes a request header by key if present. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .delete_req_header(\"Referer\")\n    .text(nil)\nend\n</code></pre>"},{"location":"context/#delete_resp_header","title":"delete_resp_header","text":"<p>Deletes a response header by key if present. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .json(\"Hello, World!\")\n    .delete_resp_header(\"Content-Type\")\nend\n</code></pre>"},{"location":"context/#get_req_header","title":"get_req_header","text":"<p>Returns the value of the request header specified by <code>key</code>. Raises <code>KeyError</code> if not found.</p> <pre><code>def get(context : Context) : Context\n  referer =\n    context\n      .get_req_header(\"Referer\")\n\n  context\n    .json(\n      {\n        \"referer\" =&gt; referer\n      }\n    )\nend\n</code></pre>"},{"location":"context/#get_req_header_1","title":"get_req_header?","text":"<p>Returns the value of the request header specified by <code>key</code>, or <code>nil</code> if not found.</p> <pre><code>def get(context : Context) : Context\n  referer =\n    context\n      .get_req_header?(\"Referer\")\n\n  context\n    .json(\n      {\n        \"referer\" =&gt; referer || \"No Referer\"\n      }\n    )\nend\n</code></pre>"},{"location":"context/#get_req_cookie","title":"get_req_cookie","text":"<p>Returns the cookie from the request specified by <code>key</code>, or <code>nil</code> if not found.</p> <pre><code>def get(context : Context) : Context\n  cookie =\n    context\n      .get_req_cookie(\"MyCookie\")\n\n  context\n    .json(\n      {\n        \"cookie\" =&gt; cookie.try(&amp;.value) || \"No Cookie\"\n      }\n    )\nend\n</code></pre>"},{"location":"context/#get_resp_header","title":"get_resp_header","text":"<p>Returns the value of the response header specified by <code>key</code>. Raises <code>KeyError</code> if not found.</p> <pre><code>def get(context : Context) : Context\n  content_type =\n    context\n      .get_resp_header(\"Content-Type\")\n\n  context\n    .json(\n      {\n        \"contentType\" =&gt; content_type\n      }\n    )\nend\n</code></pre>"},{"location":"context/#halt","title":"halt","text":"<p>Halts the function chain by closing the response stream. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .json(\"Hello, World!\")\n    .halt\nend\n</code></pre>"},{"location":"context/#merge_resp_headers","title":"merge_resp_headers","text":"<p>Merges a series of response headers into the context. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .merge_resp_headers({\"Content-Type\" =&gt; \"application/json\"})\n    .send_resp(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#put_req_header","title":"put_req_header","text":"<p>Adds or replaces a request header with the given <code>key</code> and <code>value</code>. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .put_req_header(\"Referer\", \"www.google.com\")\n    .json(\"Hello, World\")\nend\n</code></pre>"},{"location":"context/#put_resp_header","title":"put_resp_header","text":"<p>Adds or replaces a response header with the given <code>key</code> and <code>value</code>. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .put_resp_header(\"Content-Type\", \"application/json\")\n    .send_resp(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#put_resp_cookie","title":"put_resp_cookie","text":"<p>Adds or overwrites a response cookie. Accepts either a key-value pair or an <code>HTTP::Cookie</code> object. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .put_resp_cookie(\"MyCookie\", \"Cookie Value\") # Or .put_resp_cookie(HTTP::Cookie.new(\"MyCookie\", \"Cookie Value\"))\n    .send_resp(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#put_status","title":"put_status","text":"<p>Assigns the given status code to the context response. Accepts either an <code>HTTP::Status</code> or an <code>Int32</code>. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .put_status(400)\n    .json(\"Bad request\")\nend\n</code></pre>"},{"location":"context/#send_file","title":"send_file","text":"<p>Sends a file to the client. The <code>path</code> must point to an existing file. Optionally specify <code>mime_type</code> (inferred from extension if <code>nil</code>) and enable <code>gzip_enabled</code> for compression. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .send_file(\"./example.txt\")\nend\n</code></pre>"},{"location":"context/#send_resp","title":"send_resp","text":"<p>Sends a response to the client with the given content. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .send_resp(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#json","title":"json","text":"<p>Sends a JSON response. Optionally specify the <code>Content-Type</code> header. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .json(\"Hello, World!\", \"application/json; charset=UTF-8\")\nend\n</code></pre>"},{"location":"context/#html","title":"html","text":"<p>Sends an HTML response. Optionally specify the <code>Content-Type</code> header. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .html(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#text","title":"text","text":"<p>Sends a text response. Optionally specify the <code>Content-Type</code> header. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .text(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#binary","title":"binary","text":"<p>Sends a binary response. Accepts a string or <code>Bytes</code>. Optionally specify the <code>Content-Type</code> header. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .binary(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#fetch_json_params","title":"fetch_json_params","text":"<p>Fetches JSON parameters from the request body. Returns an empty hash if no parameters are available.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_json_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#fetch_query_params","title":"fetch_query_params","text":"<p>Fetches query parameters from the URL query string. Returns an empty <code>URI::Params</code> if no parameters are available.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_query_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#fetch_body_params","title":"fetch_body_params","text":"<p>Fetches URL-encoded body parameters from the request. Returns an empty <code>URI::Params</code> if no parameters are available.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_body_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#fetch_file_params","title":"fetch_file_params","text":"<p>Fetches multipart file parameters from the request. Returns an empty hash if no parameters are available.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_file_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#fetch_path_params","title":"fetch_path_params","text":"<p>Fetches path parameters from the URL. Returns an empty hash if no parameters are available.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_path_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#redirect","title":"redirect","text":"<p>Redirects the response to the specified <code>url</code> with a given status code (default <code>302 Found</code>). Accepts either an <code>HTTP::Status</code> or an <code>Int32</code>. Returns <code>self</code> for method chaining.</p> <pre><code>def get(context : Context) : Context\n  context\n    .redirect(\"/new-page\", 302)\nend\n</code></pre>"},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#heroku","title":"Heroku","text":"<p>You can use heroku-buildpack-crystal to deploy your Grip application to Heroku.</p>"},{"location":"deployment/#cross-compilation","title":"Cross Compilation","text":"<p>Cross-compilation is supported and it can be achieved using this guide</p>"},{"location":"error_handling/","title":"Error handling","text":"<p>Grip comes with a pre-defined error handlers for the JSON response type. You can customize the built-in error pages or even add your own using the <code>error</code> macro.</p> <pre><code># IndexController handles HTTP requests and demonstrates raising a Grip-specific exception.\nclass IndexController\n  include Grip::Controllers::HTTP\n\n  # Handles GET requests by raising a Forbidden exception.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] Never returns normally due to raised exception.\n  def get(context : HTTP::Server::Context) : HTTP::Server::Context\n    raise Grip::Exceptions::Forbidden.new # Triggers the ForbiddenController via the error macro.\n  end\nend\n\n# ForbiddenController handles Grip::Exceptions::Forbidden errors with a custom JSON response.\nclass ForbiddenController\n  include Grip::Controllers::Exception\n\n  # Custom handler for Forbidden exceptions, setting a 403 status and JSON error message.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a 403 status and JSON response.\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context\n      .put_status(403) # Sets HTTP status to 403 (Forbidden), inherited from the exception.\n      .json(\n        {\n          \"error\" =&gt; [\"You lack privileges to access the current resource!\"]\n        }\n      )\n  end\nend\n\n# Application configures the Grip web application with error handlers and routes.\nclass Application\n  include Grip::Application\n\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::Exception.new, # Handles exceptions using defined error controllers.\n  ] of HTTP::Handler\n\n  # Initializes the application and sets up routes.\n  def initialize\n    routes # Calls the routes method to configure routing and error handling.\n  end\n\n  # Configures routes and error handlers for the application.\n  def routes\n    # Maps Grip::Exceptions::Forbidden to ForbiddenController for custom error handling.\n    exception Grip::Exceptions::Forbidden, ForbiddenController\n  end\nend\n\n# Demonstrates the difference between manual response handling and Grip exceptions.\n# This controller shows a manual 404 response, bypassing error handlers.\nclass IndexController\n  include Grip::Controllers::HTTP\n\n  # Handles GET requests by manually setting a 404 response.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a 404 status and HTML response.\n  def get(context : HTTP::Server::Context) : HTTP::Server::Context\n    context\n      .put_status(404) # Manually sets HTTP status to 404 (Not Found).\n      .html(\"&lt;p&gt;404 Not found&lt;/p&gt;\") # Returns a simple HTML response.\n      .halt # Stops further processing, bypassing error handlers.\n  end\nend\n\n# Demonstrates raising a Grip-specific NotFound exception.\nclass IndexController\n  include Grip::Controllers::HTTP\n\n  # Handles GET requests by raising a NotFound exception.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] Never returns normally due to raised exception.\n  def get(context : HTTP::Server::Context) : HTTP::Server::Context\n    raise Grip::Exceptions::NotFound.new # Triggers the defined error handler for NotFound.\n  end\nend\n\n# FallbackController handles arbitrary exceptions with a generic JSON response.\nclass FallbackController\n  include Grip::Controllers::Exception\n\n  # Generic handler for uncaught exceptions, returning a JSON error message.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a JSON error response.\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context.json({\"error\" =&gt; \"An error occurred, please try again later.\"})\n  end\nend\n\n# Application configures the Grip web application with a fallback error handler.\nclass Application\n  include Grip::Application\n\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::Exception.new, # Handles exceptions using defined error controllers.\n  ] of HTTP::Handler\n\n  # Initializes the application and sets up routes.\n  def initialize\n    routes # Calls the routes method to configure routing and error handling.\n  end\n\n  # Configures routes and error handlers for the application.\n  def routes\n    # Maps NotImplementedError to FallbackController for generic error handling.\n    exception NotImplementedError, FallbackController\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"},{"location":"forward/","title":"Forward","text":"<p>Forward forwards a request to a specific route, mainly a HTTP::Handler class.</p> <pre><code># Authorization is an HTTP handler that processes incoming requests.\n# It accepts a username and password for potential authentication logic.\nclass Authorization\n  include HTTP::Handler\n\n  # Initializes the handler with a username and password.\n  # @param username [String] The username for authentication.\n  # @param password [String] The password for authentication.\n  def initialize(@username : String, @password : String)\n  end\n\n  # Processes the HTTP request context, currently returning it unchanged.\n  # This method can be extended to add authentication logic using @username and @password.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The unmodified context (placeholder for future logic).\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context # Returns the context as-is; can be modified to add headers or logic.\n  end\nend\n\n# Application configures the Grip web application with handlers and routes.\nclass Application\n  include Grip::Application\n\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::HTTP.new, # Handles core HTTP protocol logic.\n  ] of HTTP::Handler\n\n  # Initializes the application and sets up routes.\n  def initialize\n    routes # Calls the routes method to configure routing and forwarding.\n  end\n\n  # Configures routes for the application using the forward macro.\n  def routes\n    # Forwards all requests to the root path (\"/\") to the Authorization handler.\n    # The forward macro routes matched requests to a handler's call/1 method.\n    # @param path [String] The root path \"/\" to match requests.\n    # @param handler [Authorization] The handler class to process requests.\n    # @param username [String] The username passed to the Authorization handler.\n    # @param password [String] The password passed to the Authorization handler.\n    forward \"/\", Authorization, username: \"admin\", password: \"admin\"\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This guide provides a complete setup for a Crystal web application using the Grip framework, including project initialization, dependency setup, application code, server execution, testing, and auto-restart configuration.</p>"},{"location":"getting_started/#1-initialize-a-crystal-project","title":"1. Initialize a Crystal Project","text":"<pre><code># Initializes a new Crystal application named \"demo\" and navigates to its directory.\ncrystal init app demo &amp;&amp; cd demo\n</code></pre>"},{"location":"getting_started/#2-add-dependency-to-shardyml-and-install","title":"2. Add Dependency to <code>shard.yml</code> and Install","text":"<pre><code># shard.yml: Specifies project dependencies for the Crystal application.\nname: demo\nversion: 0.1.0\n\nauthors:\n  - Your Name &lt;your.email@example.com&gt;\n\ntargets:\n  demo:\n    main: src/demo.cr\n\ncrystal: 1.0.0\n\ndependencies:\n  grip: # Adds the Grip web framework as a dependency.\n    github: grip-framework/grip\n</code></pre> <pre><code># Installs the dependencies listed in shard.yml\nshards install\n</code></pre>"},{"location":"getting_started/#3-write-application-code-in-srcdemocr","title":"3. Write Application Code in <code>src/demo.cr</code>","text":"<pre><code># src/demo.cr: Defines the main application logic using the Grip framework.\n\n# Imports the Grip framework for building the web application.\nrequire \"grip\"\n\n# DemoController handles HTTP GET requests for the root path.\nclass DemoController\n  include Grip::Controllers::HTTP\n\n  # Handles GET requests, returning a JSON response with a custom status and header.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a 201 status, custom header, and JSON response.\n  def get(context : Context)\n    context\n      .put_status(201) # Sets the HTTP response status to 201 (Created).\n      .put_resp_header(\"Server\", \"TornadoServer/6.0.4\") # Adds a custom Server header.\n      .json( # Returns a JSON response with a simple key-value pair.\n        {\n          \"id\" =&gt; 1\n        }\n      )\n  end\nend\n\n# Application configures the Grip web application with handlers and routes.\nclass Application\n  include Grip::Application\n\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::HTTP.new, # Handles core HTTP protocol logic.\n  ] of HTTP::Handler\n\n  # Initializes the application and sets up routes.\n  def initialize\n    routes # Calls the routes method to configure routing.\n  end\n\n  # Configures routes for the application.\n  def routes\n    # Maps GET requests to the root path (\"/\") to DemoController's get method.\n    # The get method is indirectly called via a Proc, as Grip wraps controller methods.\n    get \"/\", DemoController\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"},{"location":"getting_started/#4-run-the-server","title":"4. Run the Server","text":"<pre><code># Compiles and runs the Crystal application, starting the Grip server.\n# The server listens on 0.0.0.0:4004 by default unless configured otherwise.\ncrystal src/demo.cr\n</code></pre>"},{"location":"getting_started/#5-send-a-request","title":"5. Send a Request","text":"<pre><code># Sends an HTTP GET request to the root path of the running server.\n# Expects a 201 response with a JSON body {\"id\": 1} and a Server header.\ncurl \"http://0.0.0.0:4004/\"\n</code></pre>"},{"location":"getting_started/#6-auto-restart-server","title":"6. Auto-Restart Server","text":"<pre><code># Installs nodemon globally to watch for file changes and auto-restart the server.\nsudo npm install -g nodemon\n\n# Runs nodemon to monitor .cr and .yml files, automatically restarting the server\n# by executing \"crystal run src/demo.cr\" when changes are detected.\nnodemon -e \"cr,yml\" --exec \"crystal run\" src/demo.cr\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>To use the Grip framework in a Crystal application, you must add it as a dependency in the project\u2019s <code>shard.yml</code> file and install it using the <code>shards</code> command. This ensures the framework is available for building RESTful web applications.</p>"},{"location":"installation/#1-update-shardyml","title":"1. Update <code>shard.yml</code>","text":"<p>Add the Grip dependency to your project\u2019s <code>shard.yml</code> file, located in the project root directory. This file specifies the project\u2019s metadata and dependencies.</p> <pre><code># shard.yml: Configuration file for project dependencies and metadata.\ndependencies:\n  grip:\n    github: grip-framework/grip # References the Grip repository on GitHub.\n</code></pre>"},{"location":"installation/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>Run the following command in your terminal:</p> <pre><code># Installs dependencies specified in shard.yml, downloading Grip to the lib/ directory.\nshards install\n</code></pre>"},{"location":"pipe_middleware/","title":"Middleware","text":"<p>Creating a custom middleware is as easy as creating an <code>HTTP handler</code>:</p> <pre><code># src/application.cr: Defines a Grip application with custom middleware and routing.\n\n# Imports the Grip framework for building the web application.\nrequire \"grip\"\n\n# Example is a custom middleware that processes HTTP requests.\nclass Example\n  include HTTP::Handler\n\n  # Processes the HTTP request context, returning it for further handling.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context, optionally modified for the next handler.\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context # Returns the context unchanged; can be extended to mutate headers or other properties.\n  end\nend\n\n# DemoController handles HTTP GET requests for specific routes.\nclass DemoController\n  include Grip::Controllers::HTTP\n\n  # Responds to GET requests with a JSON response.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a JSON response.\n  def get(context : Context) : Context\n    context\n      .json(\"Hello, World!\") # Returns a JSON response with a greeting.\n  end\nend\n\n# Application configures and runs a Grip web application.\nclass Application\n  include Grip::Application\n\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::Pipeline.new, # Manages the request pipeline for middleware execution.\n    Grip::Handlers::HTTP.new      # Handles core HTTP protocol logic.\n  ] of HTTP::Handler\n\n  # Initializes the application and configures routes.\n  def initialize\n    routes # Calls the routes method to set up routing and pipelines.\n  end\n\n  # Defines routing structure and pipelines for the application.\n  def routes\n    # Defines a pipeline for web requests, applying the custom Example middleware.\n    pipeline :web, [\n      Example.new # Applies the custom middleware to process requests.\n    ]\n\n    # Defines a pipeline for API requests, also applying the Example middleware.\n    pipeline :api, [\n      Example.new # Applies the custom middleware to process requests.\n    ]\n\n    # Routes under the root path (\"/\").\n    scope \"/\" do\n      pipe_through :web # Applies the :web pipeline (Example middleware) to requests.\n\n      # Maps GET \"/\" to DemoController\u2019s get method.\n      get \"/\", DemoController\n\n      # Routes under the \"/users\" namespace.\n      scope \"/users\" do\n        # Applies both :web and :api pipelines (two instances of Example middleware).\n        pipe_through :api\n\n        # Maps GET \"/users/\" to DemoController\u2019s get method.\n\n        get \"/\", DemoController\n      end\n    end\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre> <p>Advantage of the pipe over a raw middleware is that you can controll which routes go through the middleware and which don't.</p>"},{"location":"runtime_flags/","title":"Configuration flags","text":"<ol> <li>Flag which enables HTTPS:</li> </ol> <pre><code>crystal run ./src/appliaction.cr -Dssl\n</code></pre>"},{"location":"scope/","title":"Scope","text":"<p>Scope defines a prefix for routes which will be nested in a block.</p> <pre><code># src/application.cr: Defines a Grip application with nested routing.\n\n# Imports the Grip framework for building the web application.\nrequire \"grip\"\n\n# DemoController handles HTTP GET requests for specific routes.\nclass DemoController\n  include Grip::Controllers::HTTP\n\n  # Responds to GET requests with a JSON response.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a JSON response (null in this case).\n  def get(context : Context) : Context\n    context\n      .json(nil) # Returns a JSON response with null content.\n  end\nend\n\n# Application configures and runs a Grip web application.\nclass Application\n  include Grip::Application\n\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::HTTP.new # Handles core HTTP protocol logic.\n  ] of HTTP::Handler\n\n  # Initializes the application and configures routes.\n  def initialize\n    routes # Calls the routes method to set up routing.\n  end\n\n  # Defines nested routing structure for the application.\n  def routes\n    # Routes under the \"/api/v1\" namespace.\n    scope \"/api/v1\" do\n      # Maps GET \"/api/v1/\" to DemoController\u2019s get method.\n      get \"/\", DemoController\n\n      # Routes under the \"/api/v1/users\" namespace.\n      scope \"/users\" do\n        # Maps GET \"/api/v1/users/\" to DemoController\u2019s get method.\n        get \"/\", DemoController\n\n        # Empty scope allows you to pipe_through routes you do not want to branch out\n        scope do\n          # Maps GET \"/api/v1/users/1/\" to DemoController\u2019s get method.\n          get \"/1\", DemoController\n        end\n      end\n    end\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"},{"location":"ssl/","title":"SSL","text":"<p>Grip has built-in and easy to use SSL support, it can be configured easily and deployed instantly.</p> <p>To start your Grip application with SSL support, use:</p> <pre><code>KEY=PATH_TO_THE_KEY CERTIFICATE=PATH_TO_THE_CERTIFICATE crystal run ./src/application.cr -Dssl\n</code></pre>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#1-add-spectator-to-shardyml","title":"1. Add Spectator to <code>shard.yml</code>","text":"<pre><code># shard.yml: Configuration file for project dependencies and metadata.\ndependencies:\n  grip:\n    github: grip-framework/grip\n\n  spectator: # Spectator testing framework for writing tests.\n    github: grip-framework/spectator\n</code></pre>"},{"location":"testing/#2-install-dependencies","title":"2. Install Dependencies","text":"<pre><code># Installs dependencies specified in shard.yml to the lib/ directory.\nshards install\n</code></pre>"},{"location":"testing/#3-configure-test-environment","title":"3. Configure Test Environment","text":"<pre><code># spec/spec_helper.cr: Sets up the test environment for the Grip application.\nrequire \"../src/your-grip-app\" # Requires the main application code.\nrequire \"spectator\" # Requires the Spectator testing framework.\n</code></pre>"},{"location":"testing/#4-grip-application-code","title":"4. Grip Application Code","text":"<pre><code># src/your-grip-app.cr: Defines a simple Grip application with a single route.\nrequire \"grip\"\n\n# Index controller handles HTTP GET requests for the root path.\nclass Index\n  include Grip::Controllers::HTTP\n\n  # Responds to GET requests with a text response.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a text response.\n  def get(context : Context) : Context\n    context\n      .text(\"Hello, World!\") # Returns a plain text response.\n  end\nend\n\n# Application configures and runs a Grip web application.\nclass Application\n  include Grip::Application\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::HTTP.new # Handles core HTTP protocol logic.\n  ] of HTTP::Handler\n\n  # Initializes the application and configures routes.\n  def initialize\n    routes # Calls the routes method to set up routing.\n  end\n\n  # Defines routes for the application.\n  def routes\n    # Maps GET \"/\" to Index controller\u2019s get method.\n    get \"/\", Index\n  end\nend\n</code></pre>"},{"location":"testing/#5-write-tests","title":"5. Write Tests","text":"<pre><code># spec/your-grip-app-spec.cr: Tests for the Grip application\u2019s Index controller.\ndescribe Index do\n  # Tests the GET \"/\" route.\n  it \"renders /\" do\n    response = get Application.new, \"/\" # Sends a GET request to the root path.\n    response.status_code.should eq 200 # Verifies the response status is 200 (OK).\n  end\nend\n</code></pre>"},{"location":"testing/#6-run-tests","title":"6. Run Tests","text":"<pre><code># Runs the test suite defined in spec/ with the test environment.\nENVIRONMENT=TEST crystal spec --verbose\n</code></pre>"},{"location":"verbs/","title":"Available verbs","text":"<p>This example demonstrates Grip\u2019s support for multiple HTTP verbs in its routing mechanism. The router maps various HTTP methods (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS) to corresponding methods in a controller, enabling flexible handling of RESTful API requests.</p>"},{"location":"verbs/#application-code","title":"Application Code","text":"<pre><code># src/application.cr: Defines a Grip application with routing for multiple HTTP verbs.\n\n# Imports the Grip framework for building the web application.\nrequire \"grip\"\n\n# DemoController handles HTTP requests for various HTTP methods.\nclass DemoController\n  include Grip::Controllers::HTTP\n\n  # Handles GET requests to the root path.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a response.\n  def get(context : Context) : Context\n    context\n  end\n\n  # Handles POST requests to the root path.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a response.\n  def post(context : Context) : Context\n    context\n  end\n\n  # Handles PUT requests to the root path.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a response.\n  def put(context : Context) : Context\n    context\n  end\n\n  # Handles DELETE requests to the root path.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a response.\n  def delete(context : Context) : Context\n    context\n  end\n\n  # Handles PATCH requests to the root path.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a response.\n  def patch(context : Context) : Context\n    context\n  end\n\n  # Handles HEAD requests to the root path.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a response.\n  def head(context : Context) : Context\n    context\n  end\n\n  # Handles OPTIONS requests to the root path.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The context with a response.\n  def options(context : Context) : Context\n    context\n  end\nend\n\n# Application configures and runs a Grip web application.\nclass Application\n  include Grip::Application\n\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::HTTP.new # Handles core HTTP protocol logic.\n  ] of HTTP::Handler\n\n  # Initializes the application and configures routes.\n  def initialize\n    routes # Calls the routes method to set up routing.\n  end\n\n  # Defines routes for multiple HTTP verbs.\n  def routes\n    # Maps GET \"/\" to DemoController\u2019s get method, wrapped in a Proc for indirect dispatch.\n    get \"/\", DemoController\n\n    # Maps POST \"/\" to DemoController\u2019s post method, wrapped in a Proc for indirect dispatch.\n    post \"/\", DemoController\n\n    # Maps PUT \"/\" to DemoController\u2019s put method, wrapped in a Proc for indirect dispatch.\n    put \"/\", DemoController\n\n    # Maps DELETE \"/\" to DemoController\u2019s delete method, wrapped in a Proc for indirect dispatch.\n    delete \"/\", DemoController\n\n    # Maps PATCH \"/\" to DemoController\u2019s patch method, wrapped in a Proc for indirect dispatch.\n    patch \"/\", DemoController\n\n    # Maps HEAD \"/\" to DemoController\u2019s head method, wrapped in a Proc for indirect dispatch.\n    head \"/\", DemoController\n\n    # Maps OPTIONS \"/\" to DemoController\u2019s options method, wrapped in a Proc for indirect dispatch.\n    options \"/\", DemoController\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"},{"location":"web_socket_routing/","title":"WebSocket routing","text":"<p>This example demonstrates Grip\u2019s WebSocket capabilities, made simple by the Crystal Programming Language\u2019s core team. It defines a WebSocket controller, custom middleware, and pipeline-based routing to handle WebSocket connections efficiently.</p>"},{"location":"web_socket_routing/#application-code","title":"Application Code","text":"<pre><code># src/application.cr: Defines a Grip application with WebSocket support and middleware.\n\n# Imports the Grip framework for building the web application.\nrequire \"grip\"\n\n# DemoController handles WebSocket connections and events.\nclass DemoController\n  include Grip::Controllers::WebSocket\n\n  # Executed when a client opens a WebSocket connection.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @param socket [Socket] The WebSocket connection.\n  def on_open(context : Context, socket : Socket) : Void\n    # Handle connection opening logic here.\n  end\n\n  # Executed when a client sends a text message.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @param socket [Socket] The WebSocket connection.\n  # @param message [String] The received text message.\n  def on_message(context : Context, socket : Socket, message : String) : Void\n    # Handle text message logic here.\n  end\n\n  # Executed when a client sends a ping message.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @param socket [Socket] The WebSocket connection.\n  # @param message [String] The ping message.\n  def on_ping(context : Context, socket : Socket, message : String) : Void\n    # Handle ping logic here.\n  end\n\n  # Executed when the server receives a pong message.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @param socket [Socket] The WebSocket connection.\n  # @param message [String] The pong message.\n  def on_pong(context : Context, socket : Socket, message : String) : Void\n    # Handle pong logic here.\n  end\n\n  # Executed when a client sends a binary message.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @param socket [Socket] The WebSocket connection.\n  # @param binary [Bytes] The binary message.\n  def on_binary(context : Context, socket : Socket, binary : Bytes) : Void\n    # Handle binary message logic here.\n  end\n\n  # Executed when a client closes the WebSocket connection.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @param socket [Socket] The WebSocket connection.\n  # @param close_code [HTTP::WebSocket::CloseCode | Int?] The close code (optional).\n  # @param message [String] The close message.\n  def on_close(context : Context, socket : Socket, close_code : HTTP::WebSocket::CloseCode | Int?, message : String) : Void\n    # Handle connection closing logic here.\n  end\nend\n\n# PoweredByHeader adds a Server header to HTTP responses.\nclass PoweredByHeader\n  include HTTP::Handler\n\n  # Adds a Server header to the response.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The modified context with the added header.\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context\n      .put_resp_header(\"Server\", \"grip\") # Sets the Server header to \"grip\".\n  end\nend\n\n# SecureHeaders adds a Security header to HTTP responses.\nclass SecureHeaders\n  include HTTP::Handler\n\n  # Adds a Security header to the response.\n  # @param context [HTTP::Server::Context] The HTTP request context.\n  # @return [HTTP::Server::Context] The modified context with the added header.\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context\n      .put_resp_header(\"Security\", \"Absolutely\") # Sets a custom Security header.\n  end\nend\n\n# Application configures and runs a Grip web application.\nclass Application\n  include Grip::Application\n\n  # Defines the array of HTTP handlers for processing requests.\n  property handlers : Array(HTTP::Handler) = [\n    Grip::Handlers::Pipeline.new, # Manages the request pipeline for middleware execution.\n    Grip::Handlers::WebSocket.new # Handles WebSocket protocol logic.\n    Grip::Handlers::HTTP.new,     # Handles core HTTP protocol logic, it must be the last one as it handles all the requests.\n  ] of HTTP::Handler\n\n  # Initializes the application and configures routes.\n  def initialize\n    routes # Calls the routes method to set up routing.\n  end\n\n  # Defines routing structure and pipelines for WebSocket connections.\n  def routes\n    # Pipeline for API requests, applying the PoweredByHeader middleware.\n    pipeline :api, [\n      PoweredByHeader.new # Adds a Server header to responses.\n    ]\n\n    # Pipeline for web requests, applying the SecureHeaders middleware.\n    pipeline :web, [\n      SecureHeaders.new # Adds a Security header to responses.\n    ]\n\n    # Routes under the root path (\"/\").\n    scope do\n      pipe_through :web # Applies the SecureHeaders middleware.\n      pipe_through :api # Applies the PoweredByHeader middleware.\n\n      # Maps WebSocket connections to \"/:id\" to DemoController\u2019s WebSocket methods.\n      # The :id parameter can be accessed via context.fetch_path_params.\n      ws \"/:id\", DemoController\n    end\n  end\nend\n\n# Instantiates and starts the Grip application.\napp = Application.new\napp.run\n</code></pre>"}]}