{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Prelude","text":"<p>Grip is a microframework for building RESTful web applications. It is designed to be modular and easy to use, with the ability to scale up to the limits of the Crystal programming language. It offers extensibility and it has integrated middleware called \"pipes\" which alter the parts of the request/response context and pass it on to the actual endpoint. It has a router which somewhat resembles that of Phoenix framework's router and most of all it is fast, peaking at 1,663,946 requests/second for plain text response.</p>"},{"location":"#project-structure","title":"Project structure","text":"<p>For example a project structure of a normal Grip application should look like this:</p> <pre><code># In this example the project name is `Echo`\nlib/                # Library\nsrc/\n    application.cr         # Entry file\n    echo/                  # Business logic, database interaction, etc.\n        ...\n    echo_web/              # Web layer to interact with the business layer.\n        views/             # Views directory\n            ...\n        controllers/       # Controllers directory\n            ...\nshards.yml                 # The package configuration file\n</code></pre>"},{"location":"advanced_routing/","title":"Advanced routing","text":"<p>The more advanced the route is the more time it takes when executed, since the call to the index function is an indirect call, meaning that the <code>index/1</code> never existed in the <code>Grip::Controllers::Http</code> class it needs to be wrapped in a <code>Proc</code> which then needs to be called.</p> <pre><code>class AuthorizationHandler\n  include HTTP::Handler\n\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context\n      .put_req_header(\"Authorization\", \"Bearer eyMANEmJeFF=\")\n  end\nend\n\nclass DemoController &lt; Grip::Controllers::Http\n  def index(context : Context) : Context\n    context\n      .json(nil)\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n        super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::Pipeline.new,\n        Grip::Handlers::HTTP.new\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    pipeline :api, [\n      AuthorizationHandler.new\n    ]\n\n    pipeline :web, [\n      HTTP::CompressHandler.new\n    ]\n\n    # The routing occurs via the `get` macro which instantiates the controller class and assigns a route\n    # to the routing mechanism.\n    #\n    # You can route the request through unlimited amounts of pipelines.\n    scope \"/\" do\n      pipe_through :web\n      pipe_through :api\n\n      get \"/\", DemoController, as: :index\n    end\n\n    scope \"/api\" do\n      pipe_through :api\n\n      scope \"/v1\" do\n        get \"/\", DemoController, as: :index\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"application/","title":"Application","text":"<p>Application class is a building class which initializes the crucial parts of the web-framework, it contains the main handler stack and the HTTP server.</p>"},{"location":"application/#available-methods","title":"Available methods","text":"<p><code>host/0</code> <code>root/0</code> <code>custom/0</code> <code>port/0</code> <code>reuse_port/0</code> <code>router/0</code> <code>server/0</code> <code>key_file/0</code> <code>cert_file/0</code> <code>run/0</code></p>"},{"location":"application/#host","title":"host","text":"<p>The host of the server.</p> <pre><code>class Application &lt; Grip::Application\n  def host : String\n    \"127.0.0.1\"\n  end\nend\n</code></pre>"},{"location":"application/#port","title":"port","text":"<p>The port of the server.</p> <pre><code>class Application &lt; Grip::Application\n  def port : Int32\n    6969\n  end\nend\n</code></pre>"},{"location":"application/#reuse_port","title":"reuse_port","text":"<p>The reuse_port boolean of the server.</p> <pre><code>class Application &lt; Grip::Application\n  def reuse_port : Bool\n    true\n  end\nend\n</code></pre>"},{"location":"application/#server","title":"server","text":"<p>The server of the application.</p> <pre><code>class Application &lt; Grip::Application\n  def server : HTTP::Server\n    HTTP::Server.new(router)\n  end\nend\n</code></pre>"},{"location":"application/#key_file","title":"key_file","text":"<p>The SSL key file location of the application.</p> <pre><code>class Application &lt; Grip::Application\n  def key_file : String\n    \"SSL_KEY_FILE_LOCATION\"\n  end\nend\n</code></pre>"},{"location":"application/#cert_file","title":"cert_file","text":"<p>The SSL certificate file location of the application.</p> <pre><code>class Application &lt; Grip::Application\n  def cert_file : String\n    \"SSL_CERTIFICATE_FILE_LOCATION\"\n  end\nend\n</code></pre>"},{"location":"application/#run","title":"run","text":"<p>The run of the application executes the main application loop.</p>"},{"location":"basic_routing/","title":"Basic routing","text":"<p>Routing is the key feature which distinguishes Grip from other Crystal based web frameworks.</p> <pre><code>class DemoController &lt; Grip::Controllers::Http\n  def get(context : Context) : Context\n    context\n      .json(nil)\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    def initialize\n        super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::HTTP.new\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    # The routing occurs via the `get` macro which instantiates the controller class and assigns a route\n    # to the routing mechanism.\n    get \"/\", DemoController\n  end\nend\n</code></pre>"},{"location":"context/","title":"Context","text":"<p>Context is a class which contains the Request, Response structures of an HTTP server, since Crystal Language allows us to extend its core features we have decided to add couple of helper functions to the context class.</p>"},{"location":"context/#available-methods","title":"Available methods","text":"<p><code>exec/0</code> <code>delete_req_header/1</code> <code>delete_resp_header/1</code> <code>get_req_header/1</code> <code>get_resp_header/1</code> <code>halt/0</code> <code>merge_resp_headers/1</code> <code>put_req_header/2</code> <code>put_resp_header/2</code> <code>put_resp_cookie/2</code> <code>put_status/1</code> <code>send_file/1</code> <code>send_resp/1</code> <code>json/2</code> <code>html/2</code> <code>text/2</code> <code>binary/2</code> <code>fetch_json_params/0</code> <code>fetch_query_params/0</code> <code>fetch_body_params/0</code> <code>fetch_file_params/0</code> <code>fetch_path_params/0</code></p>"},{"location":"context/#exec","title":"exec","text":"<p>Run a block in the context scope.</p> <pre><code>def get(context : Context)\n  context.exec do\n    put_status(201) # Put a response status code.\n    put_resp_header(\"Server\", \"TornadoServer/6.0.4\") # Put a response header.\n    json( # Respond with JSON encoded data.\n      {\n        \"id\" =&gt; 1\n      }\n    )\n  end\nend\n</code></pre>"},{"location":"context/#delete_req_header","title":"delete_req_header","text":"<p>Deletes a request header if present.</p> <pre><code>def get(context : Context) : Context\n  context\n    .delete_req_header(\"Referer\")\n    .text(nil)\nend\n</code></pre>"},{"location":"context/#delete_resp_header","title":"delete_resp_header","text":"<p>Deletes a response header if present.</p> <pre><code>def get(context : Context) : Context\n  context\n    .json(\"Hello, World!\")\n    .delete_resp_header(\"Content-Type\")\nend\n</code></pre>"},{"location":"context/#get_req_header","title":"get_req_header","text":"<p>Returns the values of the request header specified by <code>key</code>.</p> <pre><code>def get(context : Context) : Context\n  referer =\n    context\n      .get_req_header(\"Referer\")\n\n  context\n    .json(\n      {\n        \"referer\" =&gt; referer\n      }\n    )\nend\n</code></pre>"},{"location":"context/#get_resp_header","title":"get_resp_header","text":"<p>Returns the values of the response header specified by <code>key</code>.</p> <pre><code>def get(context : Context) : Context\n  content_type =\n    context\n      .get_resp_header(\"Content-Type\")\n\n  context\n    .json(\n      {\n        \"contentType\" =&gt; content_type\n      }\n    )\nend\n</code></pre>"},{"location":"context/#halt","title":"halt","text":"<p>Halts the function chain by closing the response stream.</p> <pre><code>def get(context : Context) : Context\n  context\n    .json(\"Hello, World!\")\n    .halt\nend\n</code></pre>"},{"location":"context/#merge_resp_headers","title":"merge_resp_headers","text":"<p>Merges a series of response headers into the context.</p> <pre><code>def get(context : Context) : Context\n  context\n    .merge_resp_headers({\"Content-Type\" =&gt; \"application/json\"})\n    .send_resp(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#put_req_header","title":"put_req_header","text":"<p>Adds a new request header <code>(key)</code> if not present, otherwise replaces the previous value of that header with <code>value</code>.</p> <pre><code>def get(context : Context) : Context\n  context\n    .put_req_header(\"Referer\", \"www.google.com\")\n    .json(\"Hello, World\")\nend\n</code></pre>"},{"location":"context/#put_resp_header","title":"put_resp_header","text":"<p>Adds a new response header <code>(key)</code> if not present, otherwise replaces the previous value of that header with <code>value</code>.</p> <pre><code>def get(context : Context) : Context\n  context\n    .put_resp_header(\"Content-Type\", \"application/json\")\n    .send_resp(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#put_resp_cookie","title":"put_resp_cookie","text":"<p>Adds a new cookie to the response. If the cookie already exists it will be overwritten.</p> <pre><code>def get(context : Context) : Context\n  context\n    .put_resp_cookie(\"MyCookie\", \"Cookie Value\") # Or .put_resp_cookie(HTTP::Cookie.new(\"MyCookie\", \"Cookie Value\"))\n    .send_resp(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#put_status","title":"put_status","text":"<p>Assigns the given status code to the context response.</p> <pre><code>def get(context : Context) : Context\n  context\n    .put_status(400)\n    .json(\"Bad request\")\nend\n</code></pre>"},{"location":"context/#send_file","title":"send_file","text":"<p>Sends a file to the client.</p> <pre><code>def get(context : Context) : Context\n  context\n    .send_file(\"./example.txt\")\nend\n</code></pre>"},{"location":"context/#send_resp","title":"send_resp","text":"<p>Sends a response to the client.</p> <pre><code>def get(context : Context) : Context\n  context\n    .send_resp(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#json","title":"json","text":"<p>Sends JSON response.</p> <p>The function has an optional second argument for the <code>Content-Type</code> header.</p> <pre><code>def get(context : Context) : Context\n  context\n    .json(\"Hello, World!\", \"application/json; charset=UTF-8\")\nend\n</code></pre>"},{"location":"context/#html","title":"html","text":"<p>Sends HTML response.</p> <p>The function has an optional second argument for the <code>Content-Type</code> header.</p> <pre><code>def get(context : Context) : Context\n  context\n    .html(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#text","title":"text","text":"<p>Sends text response.</p> <p>The function has an optional second argument for the <code>Content-Type</code> header.</p> <pre><code>def get(context : Context) : Context\n  context\n    .text(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#binary","title":"binary","text":"<p>Sends binary response.</p> <p>The function has an optional second argument for the <code>Content-Type</code> header.</p> <pre><code>def get(context : Context) : Context\n  context\n    .binary(\"Hello, World!\")\nend\n</code></pre>"},{"location":"context/#fetch_json_params","title":"fetch_json_params","text":"<p>Fetches JSON parameters from the JSON parser.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_json_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#fetch_query_params","title":"fetch_query_params","text":"<p>Fetches query parameters from the query string.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_query_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#fetch_body_params","title":"fetch_body_params","text":"<p>Fetches body parameters from the body parser.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_body_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#fetch_file_params","title":"fetch_file_params","text":"<p>Fetches file parameters from the file parser.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_file_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"context/#fetch_path_params","title":"fetch_path_params","text":"<p>Fetches path parameters from the path parser.</p> <pre><code>def get(context : Context) : Context\n  params =\n    context\n      .fetch_path_params\n\n  context\n    .json(params)\nend\n</code></pre>"},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#heroku","title":"Heroku","text":"<p>You can use heroku-buildpack-crystal to deploy your Grip application to Heroku.</p>"},{"location":"deployment/#cross-compilation","title":"Cross Compilation","text":"<p>Cross-compilation is supported and it can be achieved using this guide</p>"},{"location":"error_handling/","title":"Error handling","text":"<p>Grip comes with a pre-defined error handlers for the JSON response type. You can customize the built-in error pages or even add your own using the <code>error</code> macro.</p> <pre><code>class IndexController &lt; Grip::Controllers::Http\n  def get(context : Context) : Context\n    raise Grip::Exceptions::Forbidden.new\n  end\nend\n\nclass ForbiddenController &lt; Grip::Controllers::Exception\n  def call(context : Context) : Context\n    context\n      .put_status(403) # Raised exception automatically carries over the status code if inherited from the base class.\n      .json(\n        {\n          \"error\" =&gt; [\"You lack privileges to access the current resource!\"]\n        }\n      )\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::Exception.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    exception Grip::Exceptions::Forbidden, ForbiddenController\n  end\nend\n</code></pre>"},{"location":"error_handling/#difference-between-native-and-inherited-exceptions","title":"Difference between native and inherited exceptions","text":"<p>Keep in mind that if you won't use one of the classes from the <code>Exceptions</code> module this will just return as a normal response:</p> <pre><code>class IndexController &lt; Grip::Controllers::Http\n  def get(context : Context) : Context\n    context\n      .put_status(404)\n      .html(\"&lt;p&gt;404 Not found&lt;/p&gt;\")\n      .halt\n  end\nend\n</code></pre> <p>and this will trigger an error handler defined in the routes method of the application:</p> <pre><code>class IndexController &lt; Grip::Controllers::Http\n  def get(context : Context) : Context\n    raise Grip::Exceptions::NotFound.new\n  end\nend\n</code></pre> <p>You can also raise any exception you want and handle it in the error handler like this:</p> <pre><code>class FallbackController &lt; Grip::Controllers::Exception\n  def call(context : Context) : Context\n    context.json({\"error\" =&gt; \"An error occured, please try again later.\"})\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::Exception.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    exception NotImplementedError, FallbackController\n  end\nend\n</code></pre>"},{"location":"forward/","title":"Forward","text":"<p>Forward forwards a request to a specific route, mainly a HTTP::Handler class.</p> <pre><code>class Authorization\n  include HTTP::Handler\n\n  def initialize(@username : String, @password : String); end\n\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::HTTP.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n\n    # Forward macro simply routes the matched requests to a certain Base controller\n    # which contains a single call/1 function.\n    forward \"/\", Authorization, username: \"admin\", password: \"admin\"\n  end\nend\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>1.Init a Crystal project.</p> <pre><code>crystal init app demo &amp;&amp; cd demo\n</code></pre> <p>2.Add the dependency to your shard.yml and run <code>shards install</code>.</p> <pre><code>dependencies:\n  grip:\n    github: grip-framework/grip\n</code></pre> <p>3.Write down the following code in <code>src/demo.cr</code>.</p> <pre><code>require \"grip\"\n\nclass DemoController &lt; Grip::Controllers::Http\n  def get(context : Context)\n    context\n      .put_status(201) # Put a response status code.\n      .put_resp_header(\"Server\", \"TornadoServer/6.0.4\") # Put a response header.\n      .json( # Respond with JSON encoded data.\n        {\n          \"id\" =&gt; 1\n        }\n      )\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::HTTP.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    get \"/\", DemoController\n  end\nend\n\napp = Application.new\napp.run\n</code></pre> <p>4.Run server.</p> <pre><code>crystal src/demo.cr\n</code></pre> <p>5.Send request.</p> <pre><code>curl \"http://0.0.0.0:5000/\"\n</code></pre> <p>6.Auto restart server.</p> <pre><code># Use nodemon to watch file changed and auto restart server.\nsudo npm install -g nodemon\nnodemon -e \"cr,yml\" --exec \"crystal run\" src/demo.cr\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Add this to your application's <code>shard.yml</code>:</p> <pre><code>dependencies:\n  grip:\n    github: grip-framework/grip\n</code></pre> <p>And run this command in your terminal:</p> <pre><code>shards install\n</code></pre>"},{"location":"intermediate_routing/","title":"Intermediate routing","text":"<p>The routing mechanism is based on <code>Kemal</code> which uses the radix tree implementation to identify the URL patterns.</p> <pre><code>class DemoController &lt; Grip::Controllers::Http\n  def index(context : Context) : Context\n    context\n      .json(nil)\n  end\n\n  def get_name(context : Context) : Context\n    params =\n      context\n        .fetch_path_params\n\n    context\n      .json(params) # =&gt; {\"name\" =&gt; \"John\"} for '/John', {\"name\" =&gt; \"Jane\"} for '/Jane'\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::HTTP.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    # The routing occurs via the `get` macro which instantiates the controller class and assigns a route\n    # to the routing mechanism, the `as` keyword creates a Proc(Context, Context) and wraps it around\n    # the index/1 function of the DemoController.\n    get \"/\", DemoController, as: :index\n    get \"/:name\", DemoController, as: :get_name\n  end\nend\n</code></pre>"},{"location":"pipe_middleware/","title":"Pipe middleware","text":"<p>Pipe middleware is the building block of the framework.</p> <p>Creating a custom pipe is as easy as creating an <code>HTTP handler</code>:</p> <pre><code>class DemoPipe\n  include HTTP::Handler\n\n  # Keep in mind calling the call_next() function is prohibited here.\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    # Mutate the context and pass it on to the next handler.\n  end\nend\n\nclass DemoController &lt; Grip::Controllers::Http\n  def get(context : Context) : Context\n    context\n      .json(\"Hello, World!\")\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::Pipeline.new,\n        Grip::Handlers::HTTP.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    # Creating a pipeline with a single pipe to be routed through.\n    pipeline :web, [\n      DemoPipe.new\n    ]\n\n    pipeline :api, [\n      DemoPipe.new\n    ]\n\n    scope \"/\" do\n      pipe_through :web\n\n      get \"/\", DemoController\n\n      scope \"/users\" do\n        # This will go through [:web, :api].\n        pipe_through :api\n\n        get \"/\", DemoController\n      end\n    end\n  end\nend\n</code></pre> <p>Advantage of the pipe over a raw middleware is that you can controll which routes go through the middleware and which don't.</p>"},{"location":"raw_middleware/","title":"Raw middleware","text":"<p>In Grip raw middlewares are mentioned as handlers, when creating a handler you include the <code>HTTP::Handler</code> module and define a call/1 function.</p> <pre><code>class DemoHandler\n  include HTTP::Handler\n\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    # Mutate the context and pass it on to the next handler.\n    call_next(context)\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        DemoHandler.new,\n        Grip::Handlers::HTTP.new,\n      ] of HTTP::Handler\n    )\n  end\nend\n</code></pre>"},{"location":"runtime_flags/","title":"Configuration flags","text":"<ol> <li>Flag which enables HTTPS:</li> </ol> <pre><code>crystal run ./src/appliaction.cr -Dssl\n</code></pre>"},{"location":"scope/","title":"Scope","text":"<p>Scope defines a prefix for routes which will be nested in a block.</p> <pre><code>class DemoController &lt; Grip::Controllers::Http\n  def get(context : Context) : Context\n    context\n      .json(nil)\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::HTTP.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    # The route gets built from the ground starting from the lowest GET /, to the top /api/v1.\n    scope \"/api/v1\" do\n      get \"/\", DemoController\n\n      scope \"/users\" do\n        get \"/\", DemoController\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"ssl/","title":"SSL","text":"<p>Grip has built-in and easy to use SSL support, it can be configured easily and deployed instantly.</p> <p>To start your Grip application with SSL support, use:</p> <pre><code>KEY=PATH_TO_THE_KEY CERTIFICATE=PATH_TO_THE_CERTIFICATE crystal run ./src/application.cr -Dssl\n</code></pre>"},{"location":"testing/","title":"Testing","text":"<p>1.Add spectator to your shard.yml file as a dependencie.</p> <pre><code>dependencies:\n  grip:\n    github: grip-framework/grip\n\n  spectator:\n    github: grip-framework/spectator\n</code></pre> <p>2.Then run shards to get the dependencies:</p> <pre><code>$ shards install\n</code></pre> <p>3.Now you should require it before your files in your spec/spec_helper.cr</p> <pre><code>require \"../src/your-grip-app\"\nrequire \"spectator\"\n</code></pre> <p>For example, your Grip application:</p> <pre><code># src/your-grip-app.cr\n\nrequire \"grip\"\n\nclass Index &lt; Grip::Controllers::Http\n  def get(context : Context) : Context\n    context\n      .text(\"Hello, World!\")\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::HTTP.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    get \"/\", Index\n  end\nend\n</code></pre> <p>4.Now you can easily test your Grip application in your specs.</p> <pre><code>crystal spec -Dtest\n</code></pre> <pre><code># spec/your-grip-app-spec.cr\n\ndescribe Index do\n  # You can use GET, POST, PUT, PATCH, DELETE to call the corresponding route.\n  it \"renders /\" do\n    response = get Application.new, \"/\"\n    response.status_code.should eq 200\n  end\nend\n</code></pre>"},{"location":"verbs/","title":"Available verbs","text":"<p>There are several HTTP verbs supported by the router:</p> <pre><code>class Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::HTTP.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n    get \"/\", DemoController # Routes all the `GET /` requests to DemoController.get/1\n    post \"/\", DemoController # Routes all the `POST /` requests to DemoController.post/1\n    put \"/\", DemoController # Routes all the `PUT /` requests to DemoController.put/1\n    delete \"/\", DemoController # Routes all the `DELETE /` requests to DemoController.delete/1\n    patch \"/\", DemoController # Routes all the `PATCH /` requests to DemoController.patch/1\n    head \"/\", DemoController # Routes all the `HEAD /` requests to DemoController.head/1\n    options \"/\", DemoController # Routes all the `OPTIONS /` requests to DemoController.options/1\n  end\nend\n</code></pre>"},{"location":"web_socket_routing/","title":"WebSocket routing","text":"<p>WebSockets are easy to define and use thanks to the core team of the Crystal Programming Language.</p> <pre><code>class DemoController &lt; Grip::Controllers::WebSocket\n  def on_open(context : Context, socket : Socket) : Void\n    # Executed when a client opens a connection to the server.\n  end\n\n  def on_message(context : Context, socket : Socket, message : String) : Void\n    # Executed when a client sends a message.\n  end\n\n  def on_ping(context : Context, socket : Socket, message : String) : Void\n    # Executed when a client pings the server.\n  end\n\n  def on_pong(context : Context, socket : Socket, message : String) : Void\n    # Executed when a server receives a pong.\n  end\n\n  def on_binary(context : Context, socket : Socket, binary : Bytes) : Void\n    # Executed when a client sends a binary message.\n  end\n\n  def on_close(context : Context, socket : Socket, close_code : HTTP::WebSocket::CloseCode | Int?, message : String) : Void\n    # Executed when a client closes the connection to the server.\n  end\nend\n\nclass PoweredByHeader\n  include HTTP::Handler\n\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context\n      .put_resp_header(\"Server\", \"grip\")\n  end\nend\n\nclass SecureHeaders\n  include HTTP::Handler\n\n  def call(context : HTTP::Server::Context) : HTTP::Server::Context\n    context\n      .put_resp_header(\"Security\", \"Absolutely\")\n  end\nend\n\nclass Application &lt; Grip::Application\n  def initialize\n    super(\n      environment: ENV[\"ENVIRONMENT\"]? || \"production\"\n      handlers: [\n        Grip::Handlers::Pipeline.new,\n        Grip::Handlers::HTTP.new,\n        Grip::Handlers::WebSocket.new,\n      ] of HTTP::Handler\n    )\n\n    routes()\n  end\n\n  def routes()\n\n    pipeline :api, [\n      PoweredByHeader.new\n    ]\n\n    pipeline :web, [\n      SecureHeaders.new\n    ]\n\n    # WebSockets support the pipeline routing, keep in mind that\n    # the `:id` URL here gives an option to fetch the `id` using the\n    # `context : Context.fetch_path_params/0` function.\n    scope \"/\" do\n      pipe_through :web\n      pipe_through :api\n\n      ws \"/:id\", DemoController\n    end\n  end\nend\n</code></pre>"}]}